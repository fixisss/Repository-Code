import pygame
import random
import sys
 
# --- CONFIGURAÇÕES ---
CELL_SIZE = 30
GRID_W = 20
GRID_H = 15
SCREEN_WIDTH = GRID_W * CELL_SIZE
SCREEN_HEIGHT = GRID_H * CELL_SIZE
FPS = 10
 
# Cores
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 200, 0)
RED = (255, 0, 0)
GRAY = (200, 200, 200)
BACKGROUND = (20, 20, 20)  # Fundo escuro para melhor visual
 
# --- LÓGICA DE GRAFOS ---
 
class Graph:
    def __init__(self):
        # Lista de adjacência: chave = ID do vértice, valor = lista de vizinhos
        self.adj_list = {}
 
    def add_edge(self, u, v):
        if u not in self.adj_list:
            self.adj_list[u] = []
        if v not in self.adj_list:
            self.adj_list[v] = []
        # Grafo não direcionado
        if v not in self.adj_list[u]:
            self.adj_list[u].append(v)
        if u not in self.adj_list[v]:
            self.adj_list[v].append(u)
 
    def has_edge(self, u, v):
        # Verifica se há aresta entre u e v
        return u in self.adj_list and v in self.adj_list[u]
 
# Funções Auxiliares de Mapeamento (Grid <-> Grafo)
def get_id(x, y):
    return y * GRID_W + x
 
def get_coords(id_vertice):
    y = id_vertice // GRID_W
    x = id_vertice % GRID_W
    return x, y
 
def setup_grid_graph():
    g = Graph()
    for y in range(GRID_H):
        for x in range(GRID_W):
            u = get_id(x, y)
            # Conecta com vizinhos válidos
            if x + 1 < GRID_W:
                g.add_edge(u, get_id(x + 1, y))
            if x - 1 >= 0:
                g.add_edge(u, get_id(x - 1, y))
            if y + 1 < GRID_H:
                g.add_edge(u, get_id(x, y + 1))
            if y - 1 >= 0:
                g.add_edge(u, get_id(x, y - 1))
    return g
 
# --- LÓGICA DO JOGO ---
 
def main():
    pygame.init()
    # Inicializa mixer para sons (opcional)
    pygame.mixer.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Snake Game com Grafos - Python")
    clock = pygame.time.Clock()
 
    # Carrega sons (opcional - substitua por arquivos .wav se quiser)
    # eat_sound = pygame.mixer.Sound('eat.wav')  # Adicione arquivos de som se desejar
    # game_over_sound = pygame.mixer.Sound('game_over.wav')
 
    # 1. Inicializa o Grafo
    graph = setup_grid_graph()
 
    # 2. Estado Inicial
    start_pos = get_id(GRID_W // 2, GRID_H // 2)
    snake = [start_pos]  # Lista de IDs dos vértices
    # Gera fruta garantindo que não está na cobra (com limite para evitar loop infinito)
    def get_new_fruit():
        attempts = 0
        max_attempts = GRID_W * GRID_H  # Limite seguro
        while attempts < max_attempts:
            f = random.randint(0, (GRID_W * GRID_H) - 1)
            if f not in snake:
                return f
            attempts += 1
        return -1  # Fallback (improvável)
    fruit = get_new_fruit()
    # Direção: (dx, dy)
    direction = (0, 0)
    next_direction = (0, 0)
    running = True
    game_over = False
    fruit_pulse = 0  # Para animação da fruta
 
    while running:
        # --- INPUT ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and direction != (0, 1):
                    next_direction = (0, -1)
                elif event.key == pygame.K_DOWN and direction != (0, -1):
                    next_direction = (0, 1)
                elif event.key == pygame.K_LEFT and direction != (1, 0):
                    next_direction = (-1, 0)
                elif event.key == pygame.K_RIGHT and direction != (-1, 0):
                    next_direction = (1, 0)
                elif event.key == pygame.K_r and game_over:
                    # Reiniciar
                    snake = [start_pos]
                    direction = (0, 0)
                    next_direction = (0, 0)
                    fruit = get_new_fruit()
                    game_over = False
                    # game_over_sound.play()  # Descomente se tiver som
 
        if not game_over:
            direction = next_direction
            # --- LOGICA DE MOVIMENTO VIA GRAFO ---
            if direction != (0, 0):
                # Posição atual da cabeça
                head_x, head_y = get_coords(snake[0])
                # Próxima posição geometricamente
                new_x = head_x + direction[0]
                new_y = head_y + direction[1]
                # Calcula ID da próxima posição (se válida)
                possible_next_id = -1
                if 0 <= new_x < GRID_W and 0 <= new_y < GRID_H:
                    possible_next_id = get_id(new_x, new_y)
                # Verifica se há aresta no grafo (movimento válido)
                can_move = False
                if possible_next_id != -1 and graph.has_edge(snake[0], possible_next_id):
                    can_move = True
                if not can_move:
                    game_over = True  # Bateu na "parede" (sem aresta)
                    # game_over_sound.play()  # Descomente se tiver som
                else:
                    # Verifica colisão com corpo
                    if possible_next_id in snake:
                        game_over = True
                        # game_over_sound.play()  # Descomente se tiver som
                    else:
                        # Move a cobra
                        snake.insert(0, possible_next_id)  # Nova cabeça
                        if possible_next_id == fruit:
                            fruit = get_new_fruit()
                            # eat_sound.play()  # Descomente se tiver som
                            # Não remove cauda (cresce)
                        else:
                            snake.pop()  # Remove cauda
 
        # --- DESENHO (RENDER) ---
        screen.fill(BACKGROUND)  # Fundo escuro
        # Desenha o Grid
        for x in range(0, SCREEN_WIDTH, CELL_SIZE):
            pygame.draw.line(screen, (50, 50, 50), (x, 0), (x, SCREEN_HEIGHT))
        for y in range(0, SCREEN_HEIGHT, CELL_SIZE):
            pygame.draw.line(screen, (50, 50, 50), (0, y), (SCREEN_WIDTH, y))
        # Desenha Fruta com animação (pulsando)
        fx, fy = get_coords(fruit)
        fruit_size = CELL_SIZE - 2 + int(2 * abs(pygame.time.get_ticks() % 1000 - 500) / 500)  # Pulsação simples
        pygame.draw.rect(screen, RED, ((fx * CELL_SIZE + (CELL_SIZE - fruit_size) // 2), 
                                       (fy * CELL_SIZE + (CELL_SIZE - fruit_size) // 2), 
                                       fruit_size, fruit_size))
        # Desenha Cobra
        for index, node_id in enumerate(snake):
            sx, sy = get_coords(node_id)
            color = GREEN if index == 0 else DARK_GREEN
            pygame.draw.rect(screen, color, (sx * CELL_SIZE, sy * CELL_SIZE, CELL_SIZE, CELL_SIZE))
            # Borda para separar segmentos
            pygame.draw.rect(screen, BLACK, (sx * CELL_SIZE, sy * CELL_SIZE, CELL_SIZE, CELL_SIZE), 1)
        # Desenha pontuação em tempo real
        font = pygame.font.SysFont('arial', 20)
        score_text = font.render(f"Score: {len(snake) - 1}", True, WHITE)
        screen.blit(score_text, (10, 10))
        if game_over:
            font_big = pygame.font.SysFont('arial', 40)
            text = font_big.render("Game Over!", True, RED)
            text2 = font.render("Pressione 'R' para reiniciar", True, GRAY)
            screen.blit(text, (SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 - 40))
            screen.blit(text2, (SCREEN_WIDTH // 2 - 120, SCREEN_HEIGHT // 2))
        pygame.display.flip()
        clock.tick(FPS)
    pygame.quit()
    sys.exit()
 
if __name__ == "__main__":
    main()
